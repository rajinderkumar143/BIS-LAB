import numpy as np
import random

# --- 1. Problem Definition (ELD) ---
# Data for a 3-unit system (from a common test case in research papers)
# [a, b, c, P_min, P_max] for each generator
generator_data = np.array([
    [0.008, 7.0, 200.0, 10.0, 85.0],
    [0.009, 6.3, 180.0, 10.0, 80.0],
    [0.007, 6.8, 140.0, 10.0, 70.0]
])

# Total power demand
total_demand = 150.0 # in MW

# The objective function to minimize (total generation cost)
def objective_function(P_values):
    """
    Calculates the total fuel cost for a given power output for each generator.
    P_values is a NumPy array of power outputs.
    """
    a = generator_data[:, 0]
    b = generator_data[:, 1]
    c = generator_data[:, 2]
    
    total_cost = np.sum(a * P_values**2 + b * P_values + c)
    return total_cost

# Penalty function for constraints
def calculate_fitness(P_values, total_demand, penalty_factor=1000):
    """
    Calculates the fitness of a particle, including penalties for violating constraints.
    - P_values: the current power output of generators
    - total_demand: the system load
    - penalty_factor: a large number to penalize constraint violations
    """
    # Sum of power generated
    generated_power = np.sum(P_values)
    
    # Calculate objective value (total cost)
    cost = objective_function(P_values)
    
    # Add a penalty for not meeting the power balance constraint
    # We use the squared difference to make the penalty more significant
    penalty = penalty_factor * (generated_power - total_demand)**2
    
    return cost + penalty

# --- 2. PSO Algorithm Implementation ---
class Particle:
    def __init__(self, num_dims, bounds):
        self.position = np.random.uniform(bounds[:, 0], bounds[:, 1], num_dims)
        self.velocity = np.zeros(num_dims)
        self.personal_best_position = np.copy(self.position)
        self.personal_best_fitness = float('inf')

    def update_velocity(self, global_best_position, w=0.5, c1=2.0, c2=2.0):
        r1 = random.uniform(0, 1)
        r2 = random.uniform(0, 1)
        
        # Cognitive component: towards its own best position
        cognitive_velocity = c1 * r1 * (self.personal_best_position - self.position)
        
        # Social component: towards the swarm's best position
        social_velocity = c2 * r2 * (global_best_position - self.position)
        
        self.velocity = w * self.velocity + cognitive_velocity + social_velocity

    def update_position(self, bounds):
        self.position += self.velocity
        
        # Clamp positions to stay within bounds
        self.position = np.clip(self.position, bounds[:, 0], bounds[:, 1])

def pso_optimizer(num_particles, max_iterations):
    num_generators = generator_data.shape[0]
    bounds = generator_data[:, 3:5]
    
    # Initialize the swarm
    particles = [Particle(num_generators, bounds) for _ in range(num_particles)]
    
    global_best_position = None
    global_best_fitness = float('inf')

    for i in range(max_iterations):
        for particle in particles:
            # Calculate fitness for the current position
            current_fitness = calculate_fitness(particle.position, total_demand)
            
            # Update personal best
            if current_fitness < particle.personal_best_fitness:
                particle.personal_best_fitness = current_fitness
                particle.personal_best_position = np.copy(particle.position)
            
            # Update global best
            if current_fitness < global_best_fitness:
                global_best_fitness = current_fitness
                global_best_position = np.copy(particle.position)
        
        # Update velocities and positions for all particles
        for particle in particles:
            particle.update_velocity(global_best_position)
            particle.update_position(bounds)

        # Print progress
        if (i+1) % 50 == 0:
            print(f"Iteration {i+1}: Best Fitness = {global_best_fitness:.4f}")

    return global_best_position, global_best_fitness

# --- 3. Run the Optimization ---
if __name__ == '__main__':
    num_particles = 30
    max_iterations = 200

    optimal_power, min_cost = pso_optimizer(num_particles, max_iterations)

    print("\n--- Optimization Complete ---")
    print("Optimal Power Generation (MW):")
    for i, p_gen in enumerate(optimal_power):
        print(f"  Generator {i+1}: {p_gen:.4f} MW")
    
    print(f"\nTotal Power Generated: {np.sum(optimal_power):.4f} MW")
    print(f"Total Load Demand: {total_demand} MW")
    print(f"Minimum Total Generation Cost: ${objective_function(optimal_power):.2f}")
